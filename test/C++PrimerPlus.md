[TOC]
# C++ Primer Plus读书笔记
## 第一章 基本类型——整型
1. C++不允许将函数定义嵌套在另一函数定义中。
2. 命名规则:  
    * 函数使用字母、字符、数字下划线；
    * 第一个字符不能是数字；
    * 区分大小写；
    * 不能使用关键字；
    * **以两个下划线或下划线和大写字母打头的名称被保留给实现（编译器及其使用的资源）使用，以下划线开头的名称被保留给用作全局标识符（全局名称指的是名称被什么的位置）**
3. C++基本整形（按宽度递增）：`char，short，short int，int，long，long long`，分有符号与无符号，所以共有10种。
4. short至少16位；int至少与short一样长；long至少32位且至少与int一样长；long long至少64位，且至少与long一样长。
5. 位bit 字节byte：8位的内存单元 1KB=1024字符
6. `sizeof`运算符返回类型或变量长度，单位为字节。
7. 初始化变量 `int enum={5}； int enum{5} ；int enum{}（为0）`
8. unsigned本身是`unsigned int` 的缩写
9. 整形变量行为就像里程表，超越限制其值降维另一端的取值，C++确保了无符号类型的行为，但不保证符号整形超越限制（上溢和下溢）时不出错。
10. 变量可能表示的整数值大于16位整数最大可能值，使用long，存储值超过20亿可使用longlong。
11. 仅当有大型整型数值时，才有必要使用short
12. 第一位为1-9为10进制，第一位为0，第二位为1-7为8进制，前两位为0x为16进制。
13. cout提供了控制符`dec，hex，oct`以十进制、16进制、8进制显示整数。
14. L表示long UL表示`unsigned long LL：longlong ULL：unsigned long long`。对不带后缀的十进制整数，使用`int long，long long，unsigned int long ，unsigned long，long long或unsigned long long`能存储该数的最小类型表示。
15. char虽常用来处理字符，但也可以将它用作比short更小的整型。
16. C++字符用单引号''，对字符串使用双引号""。
17. 转义序列编码： `\n`换行符 `\t`水平制表符 `\v`垂直制表符 `\b`退格 `\r`回车 `\a`振铃。
18. 与int不同的是char在默认情况下既不是没有符号也不是有符号
19. `wchar_t`宽字符类型表示扩展字符集
`char16_t,char32_t`分别表示16位无符号与32位无符号
分别用u和U表示`char16_t,char32_t`字符常量和字符串常量。
20. `const`限定符 符号常量将首字母大写
用法 `const type name=value`，声明常量时若没有提供值，则该常量值是不确定的，且无法修改。
（`const`优于`#define` 明确类型；作用域规则；用于复杂类型）  
***
## 第二章 基本类型——浮点型
1. 浮点数float
+d.dddE+n 指小数点向右移n位 +d.dddE-n指小数点向左移n位 
E之前不能有空格
2. C和C++对有效位数的要求是float至少32位，double至少48位且不少于float，long double至少和double一样多，通常float 32位，double 64位，long double为80、96或128位。另外，这三种类型的指数范围至少是-37到37.
3. float类型后缀f或F，long double型后缀L，默认情况double型，浮点数表示的范围比整数大，但运算速度慢，精度低。
4. signed char，short，int，long统称符号整型，其无符号版本统称为无符号整型。
bool，char，wchar_t符号整型和无符号整型统称整型。
float,double,long double统称浮点型。
整型和浮点型统称算术（drithmetic）型。
5. 如果两个操作数都是除法，则结果为商的整数部分，小数部分被丢弃。
6. %求模 两操作数必须为整型，用于浮点数会编译错误，如果其中一个为负数，结果的符号满足：**`(a/b)+a%b=a`**
7. 运损福优先级相同时，C++将看操作数的结合行（associativity）是从左到右还是从右到左。
8. 对不同类型进行计算时，C++将它们全部转换为同一类型。若操作数皆为double则结果为double，若皆为float，则结果为float。浮点常量在默认情况下为double。
9. 运算符重载（operator overloading）使用相同的符号进行多种操作。
10. C++自动执行很多类型的转换：
    * 将一种算数类型值赋给另一种算术类型变量；
    * 表达式包含不同算术类型；
    * 参数传递给函数时。
11. 浮点数转换成整型时采取截取而不是四舍五入。
12. 以`{}`初始化称为列表初始化，不允许缩窄
13. 强制类型转换通用格式：
`(typename) value` C语言风格
`typename value` C++风格
14. `auto`声明不指定变量类型，将其类型设置为与初始值相同。
***
## 第三章 基本类型总结
C++基本类型分为两组整数、浮点数
* 整型从小到大：`bool,char,signed char,unsigned char,short,unsigned short,int,unsigned int,long,unsigned long,long long,unsigned long long`
`short`至少16位，`int`至少与`short`一样长，`long`至少为32位至少和`int`一样长。
* 三种浮点类型分别为：`float,double,long double`
确保`float`不比`double`长，`double`不比`long double`长，通常`float` 32位，`double` 64位，`long double` 80-128位。
***
## 第四章 复合类型
### 数组
1. 数组声明应指出：
    * 存储在每个元素种值的类型；
    * 数组名；
    * 数组中元素数。
        > `typename arrayName[arraySize]`  `arragSize`必须是整型常量或`const`值也可以是常量表达式。  
2. C++数组从0开始编号。
3. 数组初始化规则：
    * 只有定义数组时才能使用初始化，此后不能再使用，也不能将一个数组赋给另一个数组
    * 可以使用下班分别给数组元素赋值
    * 对数组部分初始化则编译器将其他元素设置为0.
    * 初始化时数组[]中为空，则计算实际元素个数。
4. C++11列表初始化新增功能：
    * 初始化时可省略等号 `double earnings[4] {}`
    * 可不在大括号内包含任何东西，将所有元素置0
    * 列表初始化禁止缩窄转换。  
### 字符串
1. C++处理字符串方式有两种，一种是来自C语言（C-style string）；另一种基于string类库的方法。
2. C风格字符串必须以空字符（null character）结尾，空字符被写作\0，ASCII码为0.用来标记字符串结尾。确定存储字符串所需最短数组时，要将空字符计算在内。
3. 表示字符常量使用`'S'`，表示字符串常量使用`"S"`。
4. 任何两个由空白（空格、制表符和换行符）分隔的字符串常量会被自动拼接成一个。
5. 字符数组的长度不能短于`strlen(cosmic)+1`
6. `cin.getline(arrayName.arraySize)` 通过换行符确定行尾，但不保存换行符。
    >第三个参数暂不讨论，后续讨论  
7. `cin.get()`一种变体与上一函数参数类似，但将换行符留在输入队列中；
还有另一种变体`cin.get()`不带参数 可读取下一字符，具体使用方法：
    ```C++
    cin.get(arrayName1.Size);
    cin.get();
    cin.get(arrayName2,Size);
    ```
    或：
    ```C++
    cin.get(arrayName1.Size).get();
    cin.get(arrayName2,Size);
    ```
8. String类隐藏了字符串的数组性质：
    * **不能将一个数组赋给另一个数组，可以将一个`String`对象赋给另一个`String`对象；
    * 可以使用运算符`+`合并字符串，使用`+=`将字符串加到末尾；
9. 原始（raw）字符串 `P87`。
### 结构
1. 结构的定义方式：
    ```C++
    struct structType
    {
        type name;
        ...
    };
    structType name=
    {
        value,
        value
    };
    ```
2. C++允许在声明结构变量时省略关键字`struct`。 可以使用成员运算符`(.)`来访问各个成员。
3. **C++不提倡使用外部变量，但提倡使用外部结构声明，另外在外部声明符号常量更合理。**
### 共用体
共用体（union）是一种数据格式，能存储不同的数据类型，但只能同时存储一种类型，常用于节省内存，用于操作系统数据结构或硬件数据结构。
### 枚举
1. 使用赋值运算符显式的设置枚举量的值：
    ```C++
    enum bits{one=1,two=2,four=4,eight=8};
    ```
    也可以只显式的定义其中一些枚举量的值，没有被初始化的枚举量的值将比前面的枚举量大1.
    ```C++
    enum bigstep{first,second=100,third}
    ```
    这里`first`的默认情况为0，没被初始化的枚举量比前面大1，所以`third`为101.
可以创建多个值相同的枚举量：
    ```C++
    enum{zero,null=0,one,numero_uno=1};
    ```
    其中，zero和null都为0.
2. 枚举的取值范围定义：要找出上限，知道枚举量的最大值，找到大于最大值最小的2的幂，将他减去1，得到的便是取值范围的上限；下限，要知道枚举量的最小值，如果它不小于0，则取值范围的下限为0；否则寻找小于最小值的最大2的幂，减去-1.
### 指针和自由存储空间
1. 变量的地址 变量名前加 &
2. 指针用于存储值得地址，指针名表示的是地址 
**`*`** 运算符被称为间接值或解除引用运算符，应用于指针可得到改地址处存储的值。如`mainly`是一个指针，则 **`manly`** 表示地址，**`*manly`** 表示存储在该处的值。
3. `updates`和`* p_updates`完全等价表示值，`&updates`和`p_dates`完全等价表示地址。
4. **一定要在对指针应用解除引用运算符（*）之前，将指针初始化为一个确定的、适当的地址。**
5. 要将数字值作为地址来用，应通过强制类型转换将数字转换为适当的地址类型：
    ```C++
    int *pt;
    pt=(int *) 0xB8000000;
    ```
6. 指针真正的用处：在运行阶段分配未命名的内存以存储值
为一个数据对象（可以是结构或基本类型）获得并指定分配内存的通用格式：
    ```C++
    typeName * pointer_name = new typeName;
    ```
7. `delete`删除内存：
    ```C++
    int *ps=new int ;
    ...
    delete ps;
    ```
    这将释放ps指向的内存，但不会删除ps本身，可将ps重新指向另一个新分配的内存块。**不能用delete释放声明变量获得的内存**，例如：
    ```C++
    int juge=5;
    int *pi=&jugs;
    delete pi;
    ```
8. 数组静态联编和动态联编。
使用new创建动态数组：
    ```C++
    typeName *pointerName=new typeName [num]; 
    delete [] psome;
    ```
9. 总之，使用`new`和`delete`时应注意遵守以下规则：
    * 不要使用delete释放不是new分配的内存块；
    * 不要使用delete释放同一个内存块两次；
    * 如果使用new[ ]为数组分配内存，则应使用delete[ ]来释放；
    * 如果使用new为一个实体分配内存，则应使用delete（没有方括号）来释放；
    * 对空指针应用delete是安全的。
10. 指针与数组名：
    >使用数组表示法时：arrayName[i] becomes *(arrayName+1)
    使用指针表示法时： pointName[i] becomes *(pointName+1)  

    区别是可以修改指针的值但是数组名是常量。另外，对数组应用`sizeof`得到的是数组的长度而对指针得到的是指针的长度。
11. `&tell[0]`和`tell`都是第一个元素的地址；`&tell`是整个数组内存块的地址。
12. 在cout和C++表达式中，char数组名、char指针以及用引号括起的字符串常量都被解释为字符串第一个字符的地址。
13. 使用new创建动态结构
`structType *ps = new structType`
对于指针不能用成员运算符`.`应该使用`->`来访问成员（如果结构标识符是结构名，则使用句点运算符；如果是指向结构的指针，则使用箭头运算符）
14. **自动存储** 在函数内部定义的常规变量使用自动存储空间，被称为自动变量（automatic variable），这意味着在所属函数被调用时自动产生，在函数结束是消亡。自动变量是局部变量作用域为包含它的代码块。通常存储在栈中，按后进先出（LIFO）。
**静态存储** 是整个程序执行期间都存在的存储方式。使变量成为静态的方式：函数外面定义；声明变量时使用关键字`static`，严格限制了变量的寿命
    ```cpp
    static type name=value
    ```
    **动态存储** `new`和`delete`管理了一个内存池，在C++中被称为自由存储空间（free store）或堆（heap）。
15. 避免内存泄漏的最好方法是同时使用`new`和`delete`，***智能指针***
### 类型组合
P119
### 数组的替代品
1. 模板类`vector`使用时要包含头文件：
    ```cpp
    #include<vector>
    using namespace std;
    vector<typeName> vt(num);  //创建名为vt的vector对象，可存储num个typeName元素，num可以是整型常量也可以是整型变量。
    ```
2. 模板类array（C++11）其对象长度是固定的，也使用栈（静态内存分配） 创建语法：
    ```cpp
    #include<array>
    using namespace std;
    array<typeName,num> arr; //与vector不同的是num不能是变量
    ```
3. 数组、vector对象、array对象都可以用标准数组表示法访问各元素；array和数组存储在相同内存区域（栈）vector存储在另一区域（自由存储区或堆）；array对象可以赋值给另一对象而数组必须逐元素复制。
## 第五章 循环和关系表达式
1. 通常cout显示bool值之前将其转换为int，但`cout.setf(ios::boolalpha)`函数调用设置了一个标记命令cout显示true和false。 
2. 可以在for循环的初始化部分声明变量，但这种变量只存在于for语句中，程序离开循环后变量消失。
3. 自增与自减 前缀（prefix）`++x` 后缀（postfix）`x++` 
    ```cpp 
    //prefix
    int x = 5;
    int y= ++x; //changge x, then assign to y, y is 6, x is 5
    ```
    ```cpp
    //postfix
    int z = 5;
    int y = z++; //assign z to y,then change z; y is 5, z is 6
    ```
4. 递增\递减运算符和指针：将*和++同时用于指针，前缀递增、前缀递减和解除引用运算符优先级相同，以从右到左的方式结合（例如：`*++p`，先将++用于pt然后 `*` 应用于递增后的pt）后缀递增和后缀递减优先级相同，但比前缀运算符优先级高，以从左到右的方式结合。
`x = *pt++;`后缀运算符优先级高，意味着将运算符用于pt而不是*pt，而后缀运算符意味着对原来的地址而不是递增后的新地址解除引用，因此 `*pt++` 的值为原地址的值，但语句执行完毕后pt的值为递增后的地址。
5. 复合语句：用花括号构造复合语句（代码块），在代码块中定义一个新变量只有在执行该语句块时变量才存在，执行完毕后变量释放。
*如果语句块中声明一个变量外部也有一个这种变量，在声明位置到内部语句块结束的范围之内，新变量将隐藏旧变量；然后变量再次可见。*
6. 逗号运算符：最常见用途将两个或者更多表达式放到一个for循环表达式中；逗号表达式是第二部分的值；逗号的优先级是最低的。
7. 关系运算符优先级比算术运算符低。
8. 类型别名，建立别名的方式：
    * 使用预处理器,char替换所有的BYTE
        ```cpp
        #define BYTE char; //preprocessor replaces BYTE with char
        ```
    * 使用关键字`typedef`创建别名，不会创建新类型，只是为已有类型建立新名称
        ```cpp
        typedef typeName aliasName; //make aliasName an alias for typeName
        ```
        **使用`#define`不过声明一系列变量时不适用，例如：**
        ```cpp
        #define FLOAT_POINTER float *
        FLOAT_POINTER pa,pb;
        float * pa,pb; //pa a pointer to float,pbjust a float
        ```
9. 基于范围的for循环 对数组或容器类每个元素执行相同的操作：
    ```cpp
    double prices[5]={4.99,10.99,6.87,7.99,8.49};
    for (double x : prices)
        cout << x << endl;
    ```
    要修改数组的元素，可使用引用变量：
    ```cpp
    for (double &x : prices)
        x=x * 0.80;
    ```
10. `char * name[size]={"Jan","Feb"}` char*数组

## 第六章 分支语句和逻辑运算符
1. 将更直观的表达式`variable == value`反转为`value == variable`来捕获将相等运算符误写为赋值运算符的错误。
2. 逻辑 或运算符 `OR(||)` 这个运算法是个顺序点（sequence point） 左边子表达式先于右边子表达式（先计算左边再计算右边） **冒号和逗号运算符也是顺序点**
与运算符 `AND(&&)` 
非运算符 `NOT(!)
3. **`!`非运算符的优先级高于所有关系运算符和算术运算符，因此要对表达式求反必须用括号括起。**
`&&`运算符优先级高于`OR`运算符
4. 逻辑运算符另一种表示：

    | 运算符 | 另一种表示 |
    | ---- | ---- |
    | `&&` | and |
    | `||` | or |
    | `!` | not |
5. 字符函数库 cctype 简化诸如确定字符是否为大写字母、数字、标点符号等工作
6. `?:`运算符 条件运算符 C++中唯一一个需要3个操作数的运算符，通用格式：`expression1 ? exxpression2 : expression3` 如果expression1为true则整个表达式的值为expression2的值，否则为expression3的值。
7. switch语句 dafault可选，如果被省略又没有匹配的标签，则程序跳到switch后面的语句处执行。
    ```cpp
    switch (integer-expression)
    {
        case label1 : statements
        case label2 : statements
        ...
        default : statements
    }
    ```
8. `if else` 语句更适用于取值范围；switch语句每个case标签必须是单独的值。
9. `break`语句使程序跳到switch或循环后面的语句处执行，即结束选择或循环
 `continue`语句用于循环时，让程序跳过循环体中余下的代码并开始新循环，并没有结束循环。
10. C++也有`goto`语句 `goto paris` 跳到使用Paris作为标签的位置。
11. 文本I/O和文本文件
    1. 使用文件输出的主要步骤 
        * 包含头文件fstream
        * 创建一个ofstream对象
        * 将该ofstream对象同一个文件关联起来
        * 像使用cout那样使用ofstream对象。
    2. 使用文本读取 除非输入的文件名包含路径，否则程序将在可执行文件所属的文件夹中查找

***结构中字符串数组赋值时不能使用赋值符号，必须使用字符串赋值函数。***

## 第七章 函数
1. 定义函数：有返回值与无返回值
无返回值函数称为void函数，通用格式
    ```cpp
    void functionName(parameterList)
    {
        statement(s)
        return; //optional
    }
    ```
    有返回值函数，通用格式：
    ```cpp
    typeName functionName(parameterList)
    {
        statements;
        return value; //value is type cast to type typeName
    }
    ```
    **C++对于返回值的类型有一定限制：不能是*数组*，但可以使其他任何类型，甚至可以是结构和对象（虽然不能直接返回数组，但可以将数组作为结构或对象组成部分来返回）。** 

2. 函数在执行返回语句后结束，函数执行遇到第一条返回语句后结束。
3. 函数原型是必不可少的，但是函数原型不要求提供变量名，只提供变量类型即可。
4. 用于接收传递值的变量称为形参，用parameter参量表示形参，传递给函数的值称为实参，用参数argument表示。
5. C++将数组名解释为其第一个元素的地址。但是有一些例外：
    1、数组声明使用数组名来标记存储位置；
    2、对数组使用`sizeof`将得到整个数组的长度（以字节为单位）；
    3、将地址运算符&应用于数组名时，将返回整个数组的地址。
6. 在函数参数中可以使用`int Arr[]`传入的是数组第一个元素的地址，但是在函数体内不能使用。
7. `const double arr[]`表明指针指向常量数据，不能使用arr修改数据（只读）。
8. 使用数组区间的函数`int sumArr(const int *begin,const int *end)`开始的位置与结束的位置，必须按正确的位置传递指针。
9. `const int *p` 其中const修饰int表示指针指向常量，即*p必须为常量，防止使用指针修改指针所指向的值；(禁止修改p指向的值，但是可以指向另一个常量)
    ```cpp
    int age = 39;
    const int *pt = &age;
    *pt += 1; //INVALID
    cin >> *pt; //INVALID

    *pt = 20; //INVALID
    age = 20; //VALID
    ```  
    ```cpp
    const float g_earth = 9.80;
    const float * pe = &g_earth; //VALID

    const float g_moon = 1.63;
    float * pm = &g_moon; //INVALID 这种情况下指针可以改变常量的值，使得const显得很荒谬
    ```
   `int * const p` 其中const修饰p表示指针为常量，指针的位置不能变，防止改变指针指向的位置(可以用来修改i值，但是禁止改变指向的地址)。
10. `int (*arr)[4]`一个指向由四个int组成的数组的指针。
    `int *arr[4]`声明一个由四个指向int的指针组成的数组。
    `int arr[][4]`arr是指针而不是数组，指向由4个int指向的数组。
11. 最简单的方法是将arr看作二维数组的名称。
12. *函数和结构* 结构可以作为参数，函数也可以返回结构。当结构比较小时，按值传递比较合理. 函数形参为结构的地址，此时应该使用间接成员运算符(->)而不是成员运算符(.)  **形参类型为结构则使用的是结构副本，形成类型为指针使用的是原始结构。**
13. *函数和string对象*  P236
14. *函数和array对象* 可按值传递对象，这样处理的是对象的副本。
15. *递归* C++函数可以调用自己，C++不允许main()调用自己，被称为递归。通常的递归调用放在if语句中。包含一个递归调用的递归：
    ```cpp
    void recurs(argumentlist)
    {
        statements1
        if(test)
            recurs(arguments)
        statement2
    }
    ```
    test最终将为false，调用链将断开。只要if语句为true每个recurs()调用都将执行statement1，然后再调用recurs()而不会执行statement2，当if语句为false时，当前调用将执行statement2，当前调用结束后，程序控制权将返回给调用它的recurs()，而该recurs()将执行其statement2部分，然后结束，并将控制权返回给前一个调用，依此类推。
16. 包含多个递归调用的递归。在需要将一项工作不断分为两项较小的、类似的工作时递归非常有用，递归方法有时称为分而治之策略(divide-and-conquer strategy) 这将导致函数调用数(以及存储的变量数)翻倍，因此如果调用要求的递归层次很多，这种递归方式将是一种糟糕的选择，但是如果递归层次较少，这将是一种精致而简单的选择。
17. *函数指针* 函数也有地址，函数的地址是存储其机器语言代码的内存的开始地址。
18. * 获取函数地址 主要使用函数名（会面不跟参数）即可，如果think()是一个函数则think就说该函数的地址。**一定要区分传递的是函数的地址还是函数的返回值。
        ```cpp
        process(think); //passes address of think() to process()
        thought(think()); //passes return value of think() to thought()
        ```
        process()调用是的该函数能够在其内部调用think()函数。
    * 声明函数指针 声明指向某种数据类型的指针时，必须指定指针指向的类型，同样声明指向函数的指针时，也必须指定指针指向的函数类型，这意味着声明应指定函数的返回类型以及函数的特征标(参数列表)
        ```cpp
        double pam(int); //prototype
        double (*pf)(int); //pf points to a function 
                           //that takes one int argument 
                           //and that returns type double
        ```
        这与pam()声明类似，将其替换为了(* pf),因此(* pf)也是函数，pf是就是函数指针。* pf(int)意味着pf()是一个返回指针的函数，而(* pf)(int)意味着pf是一个指向函数的指针。
        ```cpp
        double (*pf)(int); //pf points to a function that returns double
        double * pf(int); //pf() a function that returns 
                          //a pointer to a double 
        ```
        正确声明pf后，便可以将相应函数的地址赋给它
        ```cpp
        double pam(int);
        double (*pf)(int);
        pf = pam;  //pf now points to the pam() function
        ```
        注意，pam()的特征标和返回类型必须与pf相同。
        ```cpp
        double ned(double);
        int ted(int);
        double (*pf)(int);
        pf = ned; //invalid--mismatched signature
        pd = ted; //invalid--mismatched return types
        ```
    * 使用指针来调用函数 (* pf)扮演的角色与函数名相同，因此使用(* pf)时只需将他看作函数名即可
        ```cpp
        double pam(int);
        double (*pf)(int);
        pf = pam;          //pf now points to the pam() function
        double x = pam(4); //call pam() using the function name
        double y = (*pf)(5); //also call pam() using the pointer pf
        ```
        实际上C++也允许像使用函数名那样使用pf `double y = pf(5)`，但第一种格式给了强有力的提示--代码正在使用函数指针。
19. 深入讨论函数指针 
    假设三个函数： 
    ```cpp
    const double * f1(const double ar[],int n );
    const double * f2(const double [],int );
    const double * f3(const double *,int );

    const double * (*p1)(const double *,int) = f1;
    auto p2 = f2; //使用C++11的自动类型推断功能

    cout<<(*p1)(av,3)<<": "<<*(*p1)(av,3)<<endl;
    cout<<p2(av,3)<<": "<<*p2(av,3)<<endl;
    ```
    `(*p1)(av,3)`和`p2(av,3)`都调用指向的函数，因此显示的是函数值的返回值(即double值的地址)，后面显示的是值。 可声明一个数组其三个元素为指向函数的指针：
    ```cpp
    const double * (*pa[3])(const double *,int) = {f1,f2,f3};
    ```
    首先声明一个包含三个元素的数组`pa[3]`,运算符`[]`优先级高于`*`，因此`*pa[3]`表明`pa`是一个包含三个指针的数组，表明一个包含三个指向特征标为`(const double *,int)`返回值为`const double *`的函数的指针。
    这里，不能使用`auto`，自动类型推断只能用于单值初始化而不能用于初始化列表，但是声明数组后声明同样类型的的数组可表示为`auto pb = pa`
    `pa[i]`和`pb[i]`都表示数组中的指针：
    ```cpp
    const double * px = pa[0](av,3);
    const double * py = (*pb[1])(av,3);

    double x = *pa[0](av,3);
    double y = *(*pb[1])(av,3);
    ```
    创建指向整个数组的指针，由于数组名pa是指向函数指针的指针，即它指向指针的指针，但由于可使用单个值对其进行初始化，因此可用auto：`auto pc = &pa;`
    ```cpp
    *pd[3]; //an array of 3 pointers
    (*pd)[3]; //a pointer to an array of 3 elements

    const double *(*(*pd)[3])(const double *,int) = &pa;
    ```
    `pd`指向数组，那么`* pd`就是数组，`(* pd)[i]`是数组中的元素，即函数指针，较简单的调用是`(* pd)[i](av,3)`,`* (* pd)[i](av,3)`是返回的指针指向的值，也可以使用`(* (* pd)[i])(av,3)`调用函数，`* (* (* pd)[i])(av,3)`是指向`double`的值。
20. **`pa`(是数组名，表示地址),大多数情况下`pa`是数组第一个元素的地址即`&pa[0]`因此它是单个元素的地址；但`&pa`是整个数组的地址,表面上看两个值相同，但是类型不同，`pa+1`是数组中下一个元素的地址，而`&pa+1`是数组`pa`后面一个12字节内存卡的地址（这里假定地址为4字节）。另一个差别是要得到一个元素的值，只需对`pa`解除一次引用，但需要对`&pa`解出两次应用。`**&pa == *pa == pa[0]`**
21. 自动类型推断确保变量的类型与赋给它的初值的类型一致，但是提供的初值的类型可能不对。
22. 使用`typedef`进行简化，可减少输入量让程序易于理解。
    ```cpp
    typedef const double *(*p_fun)(const double *,int); //p_fun now a type name 
    p_fun pq = f1; //pq points to the f1() function

    p_fun pa[3] = {f1,f2,f3};//pa an array of 3 function pointers
    p_fun (*pd)[3] = &pa;//pd points to an array of 3 function pointers
    ```
***
## 第七章复习题重点
1. 习题1：使用函数的三个步骤：函数声明；函数定义；函数调用。
2. 习题2.g： plot()将map结构的指针作参数，并返回一个字符串
   `char * plot(map *pmap)`
3. 习题6：将const限定符用于指针，以防止指向的原始数据被修改，程序传递基本类型时将按值传递以便函数使用副本，这样原始数据将得到保护。
4. 习题7：字符串可以存储在char数组；双引号字符串；指向字符串第一个字符的指针。
5. 习题9：`*"pizza"`表示p，`"taco"[2]`表示c。
6. 习题10：按值传递直接使用结构名`glitz`,按地址传递`&glitz`，按值传递传递可以使用副本以时间和内存为成本，可以使用常规结构成员表示法；按地址传递可以修改原始数据，必须使用间接成员运算符。
7. 习题11：函数指针`int judge(int (*pf)(const char *))`
8. 习题13：
   ```cpp
   typedef void (*p_f1)(application * pa);
   p_f1 p1 = f1;
   typedef const char * (*p_f2)(const application *,const application *);
   p_f2 p2 = f2;
   p_f1 ap[5];
   p_f2 (*pa)[10];
   ```
## 第八章 函数探幽
1. **内联函数** 提高程序运行速度所做的改进，内联函数的编译代码与其他程序代码内联起来，编译器将使用相应的函数代码替换函数调用，对于内联代码，程序无需跳到另一个位置处执行代码再跳回来，因此内联函数比常规函数稍快，但代价是需要占用更多内存。如果程序在10个不同的地方调用同一个内联函数则该程序包含该函数代码的10个副本。**应有选择的使用内联函数**如果执行函数代码的时间比处理函数调用机制的时间长，则节省的时间将只占整个过程的很小一部分，如果代码执行时间很短，则内链调用就可以节省非内联调用使用的大部分时间。另一方面，由于这个过程非常快，尽管节省了该过程的大部分时间，但节省的时间绝对值并不大，除非该函数经常被调用。要使用内联函数应采取下述措施之一：
   * 在函数声明前加上关键字inline；
   * 在函数定义前加上关键字inline。  
  
    通常的做法是省略原型，将整个定义（即函数头和所有函数代码）放在本应提供原型的地方。
2. 内联函数和宏定义 内联函数是通过传递参数实现的，而宏是通过文本替换来实现的`#define SQUARE(X) X*X`X是参数的符号标记。
3. **引用变量** C++给&符号赋予了另一个含义，将其用来声明引用，例如
   ```cpp
   int rats;
   int & rodents = rats;
   ```
   其中，&不是地址运算符，而是类型标识符的一部分，就像声明中的`char *`指的是指向`char`的指针一样，`int &`指的是指向`int`的引用，上述引用声明允许将`rats`和`rodents`互换，他们指向相同的值和内存单元。
4. 指针和引用 
   ```cpp
   int rats = 101;
   int & rodents = rats; //rodents a reference
   int * prats = &rats;  //prats a pointer
   ```
   这样，表达式rodents和*prats都可以和rats互换，而表达式&rodents、prats都可以和&rats互换。引用不同于指针之处之一是引用必须在声明引用时将其初始化而不能像指针哪有先声明再赋值。（必须在声明引用变量时进行初始化）。
   引用更接近const指针，必须在创建时进行初始化，一旦与某个变量关联起来，就将一直效忠于它，即：
   ```cpp
   int & redents = rats;
   int * const pr = &rats; //两者等价
   ```
   其中，引用rodents扮演的角色与表达式*pr相同。
5. 引用经常被用作函数参数使得函数中的变量名称为调用程序中变量的别名，这种传递参数的方法称为按引用传递。（按值传递导致被调用函数使用调用程序值的拷贝）
   ![20210131083930](https://raw.githubusercontent.com/RayYoh/PicGo/master/20210131083930.png)
6. 如果想让函数使用传递给它的信息而不对这些信息进行修改同时又想使用引用，则应使用常量引用`double refcube(const double &ra)`这样做当编译器发现代码修改了ra的值时将生成错误消息。
7. 如果实参与引用参数不匹配，C++将生成临时变量，仅当参数为const引用时C++才允许这样做。在以下两种情况下生成临时变量：实参的类型正确，但不是左值；实参的类型不正确，但可以转换为正确的类型。**左值**是可以被引用的数据对象，常规变量属于可修改的左值，const变量属于不可修改的左值。**对于形参为`const`引用的C++函数，如果实参不匹配则其行为类似于按值传递，为确保原始数据不被修改将使用临时变量来存储值。**
8. 将引用参数声明为常量数据的引用的理由：
   * 使用const可以避免无意中修改数据的编程错误；
   * 使函数能够处理const和非const实参，否则只能接受非const数据；
   * 使函数能够正确生成并使用临时变量。
9. C++11新增了右值引用(rvalue reference)这种引用可指向右值，使用`&&`声明。
10. 传统返回机制与按值传递函数参数类似，计算关键字return后的表达式并将结果返回给调用函数，概念上说这个值被复制到一个临时位置而调用程序将使用这个值。如果函数返回一个结构而不是指向结构的引用，将把整个结构复制到一个临时位置再将这个拷贝复制给变量，但再返回值为引用时将直接把值赋给变量。
11. 返回引用时应避免返回函数终止时不再存在的内存单元引用。
12. 将类对象传递给函数时，C++通常的做法是使用引用。
13. 使得能够将特性从一个类传递给另一个类的语言特性称为继承。继承的一个另一特征是基类引用可以指向派生类对象而无需进行强制类型转换。实际结果是，可以定义一个接受基类引用作为参数的函数，调用该函数时可以将基类对象作为参数也可以将派生类对象作为参数。
14. 使用引用参数的主要原因：
    * 程序猿能够修改调用函数中的数据对象；
    * 通过传递引用而不是整个数据对象可以提高程序的运行速度。
15. 使用引用、指针和按值传递的指导原则：
    对于使用传递的值而不作修改的函数：
    * 如果数据对象很小，如内置数据类型或小型结构，按值传递；
    * 如果数据对象是数组，使用指针，这是唯一的选择并将指针声明为指向const的指针；
    * 如果数据对象是较大的结构，则使用const指针或const引用以提高程序的效率，这样可以节省复制结构所需的时间和空间；
    * 如果对象是类对象则使用const引用。类设计的语义常常要求使用引用，这是C++新增这项特征的主要原因，因此传递类对象参数的标准方式是按引用传递。
    对于修改调用函数中数据的函数：
    * 如果数据对象是内置数据类型，则使用指针。
    * 如果数据类型是数组，则只能使用指针。
    * 如果数据类型是结构，则使用引用或指针。
    * 如果数据类型是类对象，则使用引用。
16. 默认参数--当函数调研中省略了实参时自动使用的一个值。 对于带参数列表的函数，必须从右向左添加默认值，即要为某个参数设置默认值则必须为它右边的所有参数提供默认值。
17. **函数多态**允许函数有多种形式，**函数重载**指的是可以有多个同名的函数。编译器在检查函数特征标时将把类型引用和类型本身视为同一个特征标，匹配函数是不区分const和非const变量。将非const值赋给const变量是合法的，但反之是非法的。！！是*特征标*而不是函数类型使得可以对函数进行重载。 调用最匹配的版本。
18. 函数重载不能滥用仅当函数基本上执行相同的任务，但使用不同形式的数据时才采用函数重载。
19. **函数模板**是通用的函数描述，使用泛型来定义函数其中泛型可以用具体的类型替换，通过将类型作为参数传递给模板。有时也称之为通用编程。函数模板允许以任意类型的方式来定义函数。
    ```cpp
    template <typename AnyType> //typename也可换为class
    void Swap(AnyType &a,AnyType &b)
    {
        AnyType temp;
        temp = a;
        a = b;
        b = temp;
    }
    ```
    最终的代码将不包含任何模板而只包含为程序生成的实际函数，使用模板的好处是使生成多个函数定义更简单、可靠。*常见的情形是*，将模板放在头文件中并在需要使用模板的文件中包含头文件。
20. 模板的局限性：编写的模板函数可能无法处理某些类型，有时通用化是有意义的但是C++语法不允许这样做。
21. 显式具体化 对于给定函数可以有非模板函数、模板函数和显示具体化模板函数以及他们的重载版本；显示具体化的原型和定义应以template<>打头，并通过名称来指出类型；**具体化优先于常规模板，而非模板函数优先于具体化和常规函数。**
22. 代码中包含函数模板本身并不会生成函数定义，只是一个用于生成函数定义的方案，编译器使用模板为特定函数生成函数定义时得到的是模板实例，这种实例化称为隐士实例化。显式实例化：
    ```cpp
    template void Swap<int>(int,int); //显式实例化
    ```
    与显示实例化不同的是，显式具体化使用如下声明之一：
    ```cpp
    template <> void Swap<int>(int &,int &);
    template <> void Swap(int &,int &);
    ```
    区别在于，这些声明的意思是“不要使用Swap()模板来生成函数定义，而应使用专门为int类型显式地定义地函数定义”。显式具体化声明在关键词template后包含<>，而显式实例化没有。
23. 对函数重载、函数模板和函数模板重载C++需要（且有）一个定义良好的策略，来决定为函数调用使用哪一个函数定义，尤其是多个参数时，这个过程称为重载解析(overloading resolution)：
    * 第一步，创建候选函数列表，其中包含与被调用函数名称相同的函数和模板函数。
    * 第二步，使用候选函数列表创建可行函数列表，这些都是参数数目正确的函数，为此有一个隐式转换序列，其中包括实参类型与相应的形参类型完全匹配的情况。
    * 第三步，确定是否有最佳的可行函数，如果有则使用，否则函数调用出错。
24. 用于找出最具体的模板的规则被称为函数模板的部分排序规则。 
25. **关键字decltype(C++11)** 使用
    ```cpp
    int x;
    decltype(x) y; // make y the same type as x
    ```
    给decltype提供的参数可以是表达式。
    ```cpp
    decltype(expression) var;
    ```
    第一步：如果expression是一个没有用括号括起的标识符,则var的类型与该标识符的类型相同，包括const等限定符；第二步：如果expression是函数调用，则var的类型与函数的返回类型相同（并不会调用函数，通过查看函数原型来获悉返回类型）；第三步：如果expression是一个左值，则var为指向其类型的引用（要进入第三步expression不能是未用括号括起的标识符）。
    ```cpp
    double xx = 4.4;
    decltyoe ((xx)) r2 = xx;
    ```
    *括号不改变表达式的值和左值性*
    第四步：如果前面条件都不满足，则var的类型与expression的类型相同。
    如果需要多次声明，可结合使用typedef和decltype：
    ```cpp
    template<typename T1,typename T2>
    void ft(T1 x,T2 y)
    {
        typedef decltype(x+y) xytype;
        xytype xpy = x+y;
        xytype arr[10];
        xytype & rxy = arr[2];
    }
    ```
## 第八章复习题重点
1. 只有一行代码的小型非递归函数适合定义为内联函数。
## 第九章 内存模型和名称空间
1. **单独编译** 头文件中通常包含的内容：函数原型；使用`#define`或`const`定义的符号常量；结构声明；类声明；模板声明；内联函数。
2. 如果文件名包含在尖括号中则C++编译器将在存储标准头文件的主机系统的文件系统中查找；但如果文件名包含在双引号中则编译器将首先查找当前工作目录或源代码目录（或其他目录，这取决于编译器），如果没有在那里找到头文件，则将在标准位置查找，因此在包含自己的头文件时应使用引号而不是尖括号。
3. 在同一个文件中只能将一个头文件包含一次，一种标准的C/C++技术可以避免多次包含同一个头文件，基于预处理器编译指令`#ifndef`(即if not define)的，下面片段意味着仅当以前没有使用预处理器编译指令`#define`定义名称COORDIN_H_时，才处理#ifdef和#endif之间的语句：
   ```cpp
   #ifndef COORIDIN_H_
   ...
   #endif
   ```
   通常使用#define语句来创建符号常量`#define MAXIMUN 4069`，但只要将#define用于名称就足已完成该名称的定义，如`#define COORDIN_H_`
4.   
   * **自动存储持续性**：在函数定义中声明的变量（包括函数参数）的存储持续性为自动的。在程序开始执行其所属的函数或代码块时被创建，在执行完成函数或者代码块时，他们使用的内存被释放，C++有两种存储持续性为自动的变量。
   * **静态存储持续性**：在函数定义外定义的变量和使用关键字`static`定义的变量的存储持续性都为静态，他们在程序整个运行过程中都存在，C++有3种存储持续性为静态的变量。
   * **线程存储持续性（C++11）**：当前，多核处理器很常见，这些CPU可同时处理多个执行任务，这让程序能够将计算放在可并行处理的不同线程种，如果变量是使用关键字`thread_local`声明的，则其生命周期与所属的线程一样长。
   * **动态存储持续性**：用`new`运算符分配的内存将一直存在，直到使用`delete`运算符将其释放或程序结束为止。这种内存的存储持续性为动态，有时被称为自由存储(free store)或堆(heap)。
5. **作用域**(scope)：描述了名称在文件（翻译单元）的多大范围内可见。
   **链接性**(linkage)：描述了名称如何在不同单元间共享。 链接性为外部的名称可在文件间共享，链接性为内部的名称只能由一个文件中的函数共享。自动变量的名称没有链接性，因为它们不能共享。
   C++作用域有多种，作用域为局部的变量只在定义它的代码块中可用；作用域为全局（也叫文件作用域）的变量在定义位置到文件结尾之间都可用。
   自动变量的作用域为为局部；静态变量的作用域是全局还是局部取决于是被如何定义的。 在函数原型作用域(function prototype scope)中使用的名称只在包含参数列表的括号内可用（这就是为什么这些名称是什么以及是否出现都不重要的原因）。在类中声明的成员的作用域为整个类。在名称空间中声明的变量的作用域为整个名称空间（由于名称空间已经引入到C++空间中，因此全局作用域是名称空间作用域的特例）。
   C++函数作用域可以是整个类或者整个名称空间（包括全局的），但不能是局部的（因为不能在代码块内定义函数，如果函数的作用域为局部，则只对自己是可见的，不能被其他函数调用）
6. **自动存储持续性**
   * 默认情况下，函数中声明的函数参数和变量的存储持续性为自动，作用域为局部，没有链接性。
   * 如果在代码块中定义了变量，则该变量的存在时间和作用域将被限制在该代码块中。 在`main()`中定义一个变量，再在`main()`中开始一个新的代码块，定义同名变量，则程序执行内部代码块中的语句时，将变量解释为局部代码块变量，新的定义隐藏(hide)以前的定义，新定义可见，旧定义暂时不可见，程序离开代码块时原来的定义又重新可见。
   * 自动变量的初始化：可以使用任何在声明时其值为已知的表达式来初始化自动变量
   * 自动变量和栈 程序运行时留出一段内存并将其视为栈，新数据被象征性的放在原有数据上面，程序使用完成后将其从栈中删除，程序使用两个指针跟踪栈，一个指针指向栈底另一个指向栈顶。函数结束后栈顶指针被重置为函数被调用前的值，从而释放新变量使用的内存。
   * 寄存器变量 register最初是C语言引入的，建议编译器使用CPU寄存器来存储自动变量，旨在提高访问变量的速度。C++11中关键字register只是显式的指出变量是自动的。
   * 静态持续变量 C++为静态存储持续性变量提供了3中链接性：外部链接性（可在其他文件中访问），内部链接性（只能在当前文件中访问）和无链接性（只能在当前函数或代码块中访问）。编译器将分配固定的内存块来存储所有的静态变量，这些变量在整个程序执行期间一直存在。如果没有显式的初始化静态变量编译器将把他设置为0.*默认情况下，静态数组和结构将每个元素或成员的所有位都置为0.* 要想创建链接性为外部的静态持续变量，必须在代码块的外面声明；要创建链接性为内部的静态持续变量，必须在代码块的外面声明并使用static限定符；要创建没有链接性的静态持续变量，必须在代码块内声明，并使用static限定符。
        ```cpp
        int global = 1000; //static duration, external linkage
        static int one_file = 50; //static duration, internbal linkage
        int main()
        {

        }
        void funct1(int n)
        {
            static int count = 0; //static duration,no linkage
            int llama = 0;
        }
        void funct2(int q)
        {

        }
        ```
        |存储描述|持续性|作用域|链接性|如何声明|
        |----|----|----|----|----|
        |自动|自动|代码块|无|在代码块中|
        |寄存器|自动|代码块|无|在代码块中，使用关键词register|
        |静态，无链接性|静态|代码块|无|在代码块中，使用关键词static|
        |静态，外部链接性|静态|文件|外部|不在任何函数内|
        |静态，内部链接性|静态|文件|内部|不在任何函数内，使用关键词static|
   * 静态变量的初始化 除默认的零初始化外，还可对静态变量进行常量表达式初始化和动态初始化，对标量类型，零将被强制转换为合适的类型。零初始和和常量表达式初始化被统称为静态初始化，这意味着在编译器处理文件（翻译单元）时初始化变量，动态初始化意味着变量将在编译后初始化。
        ```cpp
        #include<cmath>
        int x;                               //zero initialization
        int y = 5;                           //constant expression initialization
        long z = 13 * 13;                    //constant expression initialization
        const double pi = 4.0 * atan(1.0);   //dynamic initialization
        ```
        首先，x、y、z和pi被零初始化，然后编译器计算常量表达式，并将y和z分别初始化为5和169，但要初始化pi，必须调用函数atan()，这需要等到该函数被链接且程序执行时。
    * 链接性为外部的变量通常简称为外部变量，它们存储持续性为静态，作用域为整个文件。**外部变量**也称**全局变量**。
7. 单定义规则 一方面在每个使用外部变量的文件中都必须声明它；另一方面，C++有单定义规则(One Definition Rule,ODR)，变量只能有一次定义。为满足这种需求，C++提供了两种变量声明，一种是定义声明(defining declaration)或简称为定义(definition)，给变量分配存储空间；另一种是引用声明(referencing declaration)或简称声明(declaration)，不给变量分配存储空间，因为他引用已有的变量。 *引用声明使用关键词extern，且不进行初始化；否则，声明为定义，导致分配存储空间。*
   ```cpp
   double up;           //definition, up is 0
   extern int blem;     //blem defined elsewhere
   extern char gr = 'z';//definition because initialized
   ```
   如果要在多个文件中使用外部变量，只需在一个文件中包含该变量的定义（单定义规则），但在使用该变量的其他所有文件中，都必须使用关键字extern声明它：
   ```cpp
   //file01.cpp
   extern int cats = 20;    //definition because of initialization
   int dogs = 22;           //also a definition
   int fleas;               //also a definition

   //file02.cpp
   //use cats and dogs from file01.cpp
   extern int cats;         //not definitions because they use
   extern int dogs;         //extern and have no initialization

   //file98.cpp
   //use cats,dogs,and fleas from file01.cpp
   extern int cats;
   extern int dogs;
   extern int fleas;
   ```
   **注意**：单定义规则并非意味着不能有多个变量的名称相同，如在不同函数中声明的同名自动变量是彼此独立的，都有自己的地址。*虽然程序中可包含多个同名的变量，但每个变量都只有一次定义。*
8. C++提供了作用域解析运算符( :: )，放在变量名前，该运算符表示使用变量的全局版本。
9. **全局变量**所有函数都可以访问全局变量，但是程序不可靠。（*经验表明，程序越能避免对数据进行不必要的访问越能保持数据的完整性*）
10. 将static限定符用于作用域为整个文件的变量时，该变量的链接性将为内部的，在多文件程序中，链接性为内部的变量只能在其所属的文件中使用，但常规外部变量都具有外部链接性即可以在其他文件中使用。
11. 如果文件定义了一个静态外部变量，其名称与另一文件中声明的常规外部变量相同则在该文件中静态变量将隐藏常规外部变量。
12. **注意**：在多文件程序中，可以在一个文件（且只能在一个文件）中定义一个外部变量，使用该变量的其他文件必须使用关键字extern声明它。
13. 可使用外部变量在多文件程序的不同部分之间共享数据，可使用链接性为内部的静态变量在同一个文件的中的多个函数之间共享数据（名称空间提供了另外一种共享数据的方法）。
14. **无链接性的局部变量** 将static限定符用于在代码中定义的变量，将导致局部变量的存储持续性为静态。此外，如果初始化了静态局部变量则程序只在启动时进行一次初始化，再调用函数时，将不会像自动变量那样再次被初始化。
15. **说明符和限定符**  有些被称为存储说明符(storage class specifier)或cv-限定符(cv-qualifier)的C++关键字提供了其他有关存储的信息，存储说明符：
    * auto(在C++11中不再是说明符，用于自动类型推断)
    * register 在声明中指示寄存器存储，在C++11中显式的指出变量是自动的。
    * static 用在作用域为整个文件的声明时表示内部链接性；用于局部声明中，表示局部变量的存储持续性为静态。
    * extern 表明声明引用，即声明引用在其他地方定义的变量。
    * thread_local指出变量的持续性与其所属线程的持续性相同。thread_local之于线程犹如常规静态变量之于整个程序。
    * mutable 根据const来解释。
16. **cv-限定符**
    * const 最常用的cv-限定符，它表明内存被初始化后，程序不能再对它进行修改。 **默认情况下，全局变量的链接性为外部的，但const全局变量的链接性为内部的。** 内部链接性意味着每个文件都有自己的一组常量而不是所有文件共享一组常量，每个定义都是其所说文件私有的。只要两个源代码文件中包括同一个头文件，则它们将获得同一组常量。若程序员希望某个常量的链接性为外部的，则可以使用extern关键字来覆盖默认的内部链接性：
        ```cpp
        extern const int states = 50; //definition with external linkage
        ```
        这种情况下，必须在所有使用该常量的文件中使用extern关键字来声明它，**然而**鉴于单个const在多个文件之间共享，只有一个文件可以对其进行初始化。
    * volatile 表明即使程序代码没有对内存单元进行修改，其值也可能发生变化。 P317
17. **mutable** 它指出即使结构（或类）变量为const，其某个成员也可以被修改。
18. **函数链接性** 所有函数的存储持续性都自动为静态的，即在整个程序执行期间都一直存在。 默认情况下函数的链接性为外部的，即可在文件间共享（要让程序在另一个文件中查找函数，该文件必须作为程序的组成部分被编译，或者是由链接程序搜索的库文件） 还可以使用static将函数的链接性设置为内部的，使之只能在一个文件中使用，必须同时在原型和函数定义中使用该关键字。
19. **语言链接性**(language linking) P319
20. **存储方案和动态分配** 动态内存由运算符new和delete控制，而不是作用域和链接性规则控制。因此可以在一个函数中分配动态内存，而在另一个函数中将其释放。与自动内存不同动态内存不是LIFO其分配和释放顺序要取决于new和delete在何时以何种方式被使用。 通常，编译器使用三块独立的内存：**一块用于静态变量（可能再细分），一块用于自动变量，另一块用于动态存储。**
21. **使用new运算符初始化** 为内置的标量类型分配存储空间并初始化，可在类型名后面加上初始值并将其用括号括起：
    ```cpp
    int *pi = new int (6);  //*pi set to 6
    double * pd = new double (99.99); //*pd set to 99.99
    ```
    这种括号语法也可用于有合适构造函数的类，要初始化常规结构或数组需要使用大括号的列表初始化，这要求编译器支持C++11：
    ```cpp
    struct where {double x;double y;double z;};
    where * one = new where {2.5,5.3,7.2};
    int * ar = new int [4] {2,4,6,7};
    ```
    在C++11中，还可将列表初始化用于单值变量：
    ```cpp
    int *pin = new int {6};
    double * pdo = new double {99.99};
    ```
22. new失败时引发异常`std::bad_alloc`
23. **new：运算符、函数和替换函数**
24. **定位new运算符** new运算符还有另一种变体被称为定位(placement)new运算符，能够指定要使用的位置。要使用定位new特性，首先需要包含头文件new。 delete只能用于指向常规new运算符分配的堆内存。 定位new运算符的另一种用法是将其与初始化结合使用，从而将信息放在特定的硬件地址处。  
    
25. **名称空间** 在C++中名称可以是变量、函数、结构、枚举、类以及类和结构的成员。
26. **声明区域**(declaration region)可以在其中进行声明的区域。 **潜在作用域**(potential scope)从声明点开始到其声明区域的结尾。变量对程序而言可见的范围被称为**作用域**(scope)
27. C++新增了功能：通过定义一种新的声明区域来创建命名的名称空间，目的之一是提供一个声明名称的区域，一个名称空间中的名称不会与另外一个名称空间的相同名称发生冲突，同时允许程序的其他部分使用该名称空间中声明的东西。 名称空间可以是全局的也可以位于另一个名称空间中，但不能位于代码块中，因此默认情况下名称空间中声明的名称的链接性为外部。
28. 除了用户定义的名称空间外还存在全局名称空间(global namespace)，对应与文件级声明区域，全局变量位于全局名称空间中。名称空间是开放的(open)，即可以把名称加入到已有的名称空间中。未被装饰的名称(如pail)称为未限定的名称(unqualified name)，包含名称空间的名称(如Jack::pail)称为限定的名称(qualified name).
29. **using声明和using编译指令** using声明使特定的标识符可用，using编译指令使整个名称空间可用。
    using声明由被限定的名称和它前面的关键字using组成，使特定的名称添加到所属的声明区域中。在函数外面使用using声明时将把名称添加到全局名称空间中。
    ```cpp
    using Jill::fetch;  //a using declaration
    ```
    using编译指令由名称空间和关键字`using namespace`组成，使名称空间中的所有名称可用
    ```cpp
    using namespace Jack;   //make all the names in Jack avaliable
    ```
    在全局声明区域中使用using编译指令将使该名称空间的名称全局可用，在函数中使用using编译指令将使其中的名称在该函数中可用。使用using声明和using编译增加了名称冲突的可能性。
30. 使用using声明时像是声明了相应的名称一样，如果某个名称已经在函数中声明了则不能用using声明导入相同的名称，*然而，使用using编译指令时将进行名称解析，就像在包含using声明和名称空间本身的最小声明区域中声明了名称一样* 虽然函数中using编译指令将名称空间视为在函数之外声明得，但不会使得该文件中得其他函数能够使用这些名称。**一般来说，使用using声明比使用using编译指令更安全。
31. 可以将名称空间进行嵌套
    ```cpp
    namespace elements
    {
        namespace fire
        {
            int flame;
            ...
        }
        float water;
    }
    ```
    using编译指令是会传递的，如果AopB且BopC则AopC，则说操作op是可操作的。
    可以给名称空间创建别名，如：
    ```cpp
    namespace my_very_favorite_things{...};
    namespace mvft = my_very_favorite_things;
    ```
32. **未命名的名称空间** 可以通过省略名称空间的名称来创建未命名的名称空间
    ```cpp
    namespace       // unnamed namespace
    {
        int ice;
        int bandycoot;
    }
    ```
    在该名称空间中声明的名称的潜在作用域为：从声明点到声明区域末尾，从这方面看与全局变量相似，但由于没有名称，不能显式的使用using编译指令或using声明来使在其他位置可用。具体说：不能再未命名名称空间所属文件之外的其他文件中使用该名称空间中的名称。
33. 一些指导原则：
    * 使用已命名的名称空间中声明的变量，而不是使用外部全局变量；
    * 使用已命名的名称空间中声明的变量，而不是使用静态全局变量；
    * 如果开发了一个函数库或类库，将其放在一个名称空间中；
    * 仅将编译指令using作为一种将旧代码转换为使用名称空间的权宜之计；
    * 不要在头文件中使用using编译指令。首先，这样掩盖了要让哪些名称可用；另外，包含头文件额顺序可能影响程序的行为。如果非要使用编译指令using，应将其放在所有预处理器编译指令#include之后。
    * 导入名称时，首选使用作用域解析运算符或using声明的方法。
    * 对于using声明，首选将其作用域设置为局部而不是全局。
34. **总结** 
    * 一种有效的组织策略是，使用**头文件**定义用户类型，为操纵用户类型的函数提供函数原型；将函数定义放在一个独立的源代码文件中。最后，将main()和其他使用这些函数的函数放在第三个文件中。
    * C++存储方案决定了变量保留在内存中的时间（储存持续性）以及程序的哪一部分可以访问它(作用域和链接性)。
    * **自动变量**是在代码块中定义的变量，仅当程序执行到包含定义的代码块时才存在并可见。
    * **静态变量**整个程序执行期间都存在，对函数外面定义的变量所属文件中位于该变量的定义后面的所有函数都可以使用（文件作用域），并在程序的其他文件中使用（外部链接性），另一个文件要使用这种变量必须使用extern关键字声明。 对于文件间共享的变量，应在一个文件中包含其定义声明（无需使用extern，但如果同时初始化也可以使用），并在其他文件中包含引用声明（使用extern且不初始化）。在函数外面使用关键字static定义的变量的作用域为整个文件，但不能用于其他文件（内部链接性）。在代码块中使用关键字static定义的变量被限制在该代码块内（局部作用域，无链接性），但在整个程序执行期间，都一直存在且保持原值。
    * 默认情况下，**C++函数的链接性**为外部，因此可在文件中共享；但使用关键字static限定的函数的链接性为内部的，被限制在定义它的文件内。
    * 动态内存分配和释放是使用new和delete进行的，使用自由存储区或堆来存储数据，调用new占用内存，调用delete释放内存，程序使用指针跟踪这些内存单元。
    * 通过使用作用域解析运算符、using声明或using编译指令使名称空间中的标识符可用。
***
## 第九章 复习题重点
1. using声明与using编译指令的区别：using声明使得名称空间中的单个名称可用，其作用域与using所在的声明区域相同。using编译指令使名称空间中的所有名称可用。使用using编译指令时，就像在一个包含using声明和名称空间本身的最小声明区域中声明了这些名称一样。
***
## 第十章 对象和类
1. 最重要的面向对象编程（OOP）特性：抽象；封装和数据隐藏；多态；继承；代码的可重用性。
2. 指定基本类型完成了三项工作：决定数据对象需要的内存数量；决定如何解释内存中的位；决定可用数据对象执行的操作或方法。
3. **类**是一种将抽象转换为用户定义类型的C++工具，将数据表示和操纵数据的方法组合成一个整洁的包。 一般来说，类规范由两个部分组成：**类声明**以数据成员的方式描述数据部分，以成员函数（被称为方法）的方式描述公有接口；**类方法定义**描述如何实现类成员函数。 简而言之，类声明提供了类的蓝图，方法定义了提供了细节。
4. **接口**是一个共享框架供两个系统在交互时使用。接口让程序员能够编写与类对象交互的代码，从而让程序能够使用类对象。要使用某个类必须了解公共接口，要编写类必须创建其公共接口。
5. 将接口（类定义）放在头文件，将实现（类方法的代码）放在源代码文件中。
6. **访问控制** 使用类对象的程序都可以直接访问公有部分，但只能通过公有成员函数（或友元函数）来访问对象的私有成员。 公有成员函数是程序和对象的私有成员之间的桥梁提供了对象和程序之间的接口。防止程序直接访问数据被称为数据隐藏。
7. 类设计尽可能将公有接口与实现细节分开，公有接口表示设计的抽象组件，将实现细节放在一起并将它们与抽象分开被称为封装，数据隐藏是一种封装，将实现的细节隐藏在私有部分中也是一种封装，将类函数和类声明放在不同的文件中也是封装。
8. 隐藏数据是OOP的主要�����标之一，因此数据项通常放在私有部分，组成类接口的成员函数放在公有部分。通常程序员使用私有成员函数来处理不属于共有接口的实现细节。
   ```cpp
   class className
   {
       private:
        data member declarations
       public:
        member function prototypes
   };
   ```
9.  不必在类声明中使用关键字private，这是对类对象的默认访问控制，然而为了强调数据隐藏的概念，显式地使用private。
10. C++对结构进行了扩展，区别是结构的默认访问类型是public而类为private。通常使用类来实现类描述，而把结构限制为只表示纯粹的数据对象。
11. **实现类成员函数** 特征：
    * 定义成员函数时，使用作用域解析运算符(::)来标识函数所属的类，意味着另一个类的成员函数也可以有相同的命名；
        ```cpp
        void Stock::update(double price);
        void Buffoon::update();
        ```
        类方法的完整名称包括类名，`Stock::update()`是函数的限定名(qualified name)，而`update()`是全名的缩写(非限定名，unqualified name)，只能在类作用域中使用。
    * 类方法可以访问类的private组件。
12. 定义位于类声明中的函数都自动称为内联函数，类声明常将短小的成员函数作为内联函数。也可在类声明之外定义声明函数并使其成为内联函数，只需在类实现部分中定义函数时使用inline限定符即可。内联函数的特殊规则要求在每个使用它们的文件中都对其进行定义，确保内敛定义对多文件程序中的所有文件都可用、最简便的方法是：将内敛函数放在定义类的头文件中。
13. 在OOP中调用成员函数被称为发送消息。
### 类的构造函数和析构函数
1. 类设计假设用户在调用任何其他成员函数之前调用某一函数，但无法强加这种假设，避开这种问题的方法之一是在创建对象时自动对它进行初始化，为此C++提供了特殊的成员函数--类构造函数。专门用于构造新对象、将值赋给它们的数据成员。 构造函数名称与类名相同，构造函数的原型和函数头没有返回值，但没有被声明为void类型，实际上，**构造函数没有声明类型**，原型位于类声明的公有部分。程序声明对象时，将自动调用构造函数。
2. 构造函数的参数表示的不是类成员，而是赋给类成员的值，因此参数名不能与类成员相同，常见做法是在数据成员名中使用`m_`前缀，另一种常见做法是在成员中使用后缀`_`：
   ```cpp
   class Stock
   {
       private:
        string m_company; // string company_
        long m_shares;  // long shares_
   }
   ```
3. C++提供了两种使用构造函数来初始化对象的方式，一种是显式地调用构造函数，另一种是隐式地调用构造函数：
   ```cpp
   Stock garment = Stock("Furry Mason",50,2.5);
   Stock garment("Furry Mason",50,2.5);
   ```
   每次创建类对象（甚至使用new动态分配内存）时，C++都使用类构造函数，构造函数与new一起使用的方法：
   ```cpp 
   Stock *pstock = new Stock("Furry Mason",50,2.5);
   ```
   将该对象的地址赋给pstock指针，这种情况下对象没有名称，但可以使用指针管理对象。 一般来说使用对象调用方法，但无法使用对象来调用构造函数，因为在构造函数构造出对象之前，对象是不存咋的，因此构造函数被用来创建对象而不能通过对象睐调用。
4. **默认构造函数** 未提供显式初始值时用来创建对象的构造函数。 如果没有提供任何构造函数则C++将自动提供默认构造函数，是默认构造函数的隐式版本不做任何工作。*当且仅当没有定义任何构造函数时，编译器才会提供默认构造函数*，为类定义了构造函数后，程序员必须为其提供默认构造函数。 定义默认构造函数的方式有两种，一种是给已有构造函数的所有参数提供默认值，另一种方式是通过函数重载来定义---一个没有参数的构造函数。（由于只能有一个默认构造函数因此不能同时采用这两种方式。）使用了默认构造函数后，便可以声明对象变量而不对它们显式初始化。
   ```cpp
   Stock first; // calls default constructor implicitly
   Stock first = Stock(); //calls it explicitly
   Stock *prelief = new Stock; //calls it implicity

   Stock first("Concrete Conglomerate"); //calls constructor
   Stock second();  //declares a function
   Stock third; //calls default constructor
   ```
   隐式地调用默认构造函数时，不要使用圆括号。
5. **析构函数** 析构函数完成清理工作，对象过期时自动调用。析构函数的名称：类名前加上`~`，和构造函数一样，析构函数也可以没有返回值和声明类型，与构造函数不同的是，析构函数没有参数。通常不应在代码中显式的调用析构函数。如果创建的是静态存储类对象，则其析构函数将在程序结束时自动被调用；如果创建的是自动存储类对象，则其析构函数将在程序执行完代码块时自动被调用；如果对象是通过new创建的，将驻留在栈内存或自由存储区中，当使用delete来释放内存时析构函数自动被调用。  如果程序员没有提供析构函数，编译器将隐式地声明一个默认析构函数，并在发现导致对象被删除的代码后，提供默认析构函数的定义。
6. ```cpp
   Stock stock2 = Stock("Baffo Object", 2, 2.0);
   stock1 = Stock("Nifty Foods", 10, 50.0);
   ```
   第一条语句是初始化创建有指定值的对象，可能会创建临时对象（也可能不会）；第二条语句是赋值，赋值语句中使用构造函数总会导致在赋值前创建一个临时对象。 建议采用初始化方式，这种方式的效率更高。
7. C++11中可将列表初始化用于类，只要提供与某个构造函数的参数列表匹配的内容，并用大括号括起。
8. **cconst成员函数**的声明与函数的定义
    ```cpp
    void show() const; //声明
    void Stock::show() const; //定义
    ```
9. **注意**：接受一个参数的构造函数允许使用赋值语法将对象初始化为一个值：
    ```cpp 
    Classname object = value;
    ```
### this指针
1. ```cpp
    const Stock & toval(const Stock & s) const
   ```
   该函数隐式地访问一个对象，而显式地访问另一个对象并返回其中一个对象地引用。括号中的const表明，该函数不会修改被显式地访问地对象；而括号后地const表明，该函数不会修改被隐式地访问地对象，由于函数返回了一个对象地引用，因此返回类型也应为const类型。
2. this指针指向用来调用成员函数地对象。每个成员函数（包括构造函数和析构函数）都有一个this指针，它指向调用对象，如果方法需要引用整个调用对象，则可以使用表达式`*this`，在函数地括号后面使用const限定符将this限定为const，将不能使用this来修改对象的值。
3. 返回对象是引用意味着返回的是调用对象本身而不是其副本。
### 对象数组
1. 创建对象数组
   ```cpp
   Stock mystuff[4]; // creates am array of 4 Stock objects
   ```
### 类作用域
1. 在类中定义的名称（如类数据成员名和类成员函数名）的作用域为整个类，作用域为整个类的名称只在该类中是已知的，在类外是不可知的。
2. **作用域为类的常量**第一种方式是在类中声明一个枚举，在类声明中声明的枚举的作用域为整个类：
   ```cpp
   class Bakery
   {
       private: 
            enum {Months = 12};
            double costs[Months];
   }
   ```
   这种方式声明枚举并不会创建类数据成员，Months只是个符号名称，只是为了创建符号常量并不打算创建枚举类型，因此不需要提供枚举名。
   另一种在类中定义常量的方式————使用关键字static：
   ```cpp
   class Bakery
   {
       private:
            static const int Months = 12;
            double costs[Months];
   }
   ```
   这将创建一个名为Months的常量，该常量将与其他静态变量存储在一起，而不是存储在对象中。因此，只有一个Months常量被所有Bakery对象共享。
3. 作用域内枚举 传统枚举的问题之一是两个枚举定义中的枚举量可能发生冲突，为避免这种问题，C++11提供了一种新枚举，其枚举量的作用域为类：
   ```cpp
   enum class egg{Small, Medium, Large, Jumbo};
   enum class t_shirt{Small, Medium, Large, Xlarge};
   ```
   也可使用关键字struct代替class，都需要使用枚举名来限定枚举量
   ```cpp
   egg choice = egg::Large;
   t_shirt Floyd = t_shirt::Large;
   ```
   在有些情况下，常规枚举将自动转换为整型，如将其赋给int变量或用于比较表达式时，但作用域内枚举不能隐式地转换为整型，但在必要时可进行显式类型转换。
   枚举用某种底层整型类型表示，在C++98中如何选择取决于实现，因此包含枚举的结构的长度可能随系统而异，对于作用域内枚举，C++11消除了这种依赖性，默认情况下C++11作用域内枚举的底层类型为int，还提供了语法用作不同的选择：
   ```cpp
   enum class : short pizza{Small, Mdeium, Large, Xlarge};
   ```
   将底层类型指定为short，在C++11中也可以使用这种语法来指定常规枚举的底层类型，但如果没有指定，编译器选择的底层类型将随实现而异。
### 抽象数据类型（abstract data type，ADT）
   栈的特征：
   * 可创建空栈；
   * 可将数据项添加到栈顶（压入）
   * 可将栈顶删除数据项（弹出）
   * 可查看栈是否填满；
   * 可查看栈是否为空。
### 总结
1. 使用OOP方法解决编程问题的第一步是根据它与程序之间的接口来描述数据，从而指定如何使用数据，然后设计一个类来实现该接口。
2. 一般来说，私有数据成员存储信息，公有成员函数（方法）提供访问数据的唯一途径，类将数据和方法组合成一个单元，其巳酉星实现数据隐藏。
3. 通常将类声明分为两部分组成，两部分通常保存在不同的文件中，类声明（包括由函数原型表示的方法）应放在头文件，定义成员函数的源代码放在方法文件中。
4. 如果希望成员函数对多个对象进行操作，可以将额外的对象作为参数传递给它。如果方法需要显式的引用调用它的对象，则可以使用this指针，this被设置为调用对象的地址，因此*this是该对象的别名。
5. 类很适合用于描述ADT，公有成员函数接口提供了ADT描述的服务，类的私有部分和类方法的代码提供了实现，这些实现对类的客户隐藏。
***
## 第十章复习重点
1. 什么是类？
   类是用户定义的类型的定义。类声明指定了数据将如何存储，同时指定了用来访问和操纵这些数据的方法（类成员的函数）。
2. 类如何实现抽象、封装和数据隐藏？
   类表示人们可以通过类方法即公有接口对类对象执行的操作，这是抽象。类的数据成员可以是私有的（默认值），这意味着只能通过成员函数来访问这些数据，这是数据隐藏，实现的具体细节（如数据表示和方法的代码）都是隐藏的这是封装。
3. 对象和类之间的关系是什么？
   类定义了一种类型，包括如何使用它。对象是一个变量或其他数据对象（如由new生成的）并根据类定义被创建和使用。类和对象之间的关系同标准类型与其变量之间的关系相同。
4. 除了是函数之外，类函数成员与类数据成员之间的区别是什么？
   如果创建给定类的多个对象，则每个对象都有其自己的数据内存空间；但所有的对象都使用同一组成员函数（通常，方法是公有的，而数据是私有的，但这只是策略方面的问题，而不是对类的要求）
5. 类构造函数在何是被调用？类析构函数呢？
   在创建类对象或显式调用构造函数时，类的构造函数都将被调用。当对象过期时，类的析构函数将被调用。
6. 什么是默认构造函数，拥有默认构造函数有何好处？
   默认构造函数是没有参数或所有参数都有默认值的构造函数。拥有默认构造函数后，可以声明对象而不初始化它，即使已经定义了初始化构造函数。它还使得能够声明对象数组。
7. this呵*this是什么？
   this指针是类方法可以使用的指针，它指向用于调用方法的对象。因此，this是对象的地址，*this是对象本身。
***
## 第十一章 使用类
### 运算符重载
1. 要重载运算符需要使用运算符函数的特殊函数形式，格式如下：
   ```cpp
   operatorop(argument-list)
   ```
   如`operator+()`重载+运算符，op必须是有效的C++运算符，不能虚构一个新的符号。`operator[]()`函数重载`[]`运算符，`[]`是数组索引运算符。
2. **警告：**不要返回指向局部变量或临时对象的引用。函数执行完毕后，局部变量和临时对象将消失，引用将指向不存在的数据。
3. 符号重载后，可以将两个以上对象相加。
4. C++对用户定义的运算符重载的限制：
   * 重载后的运算符至少有一个操作数是用户定义的类型，这将防止用户为标准类型重载运算符；
   * 使用运算符时不能违反运算符原来的句法规则，例如不能将求模运算符重载成使用一个操作数；同样，不能修改运算符的优先级；
   * 不能创建新运算符。
   * 不能重载以下运算符：`sizeof`运算符、`.`成员运算符,`.*`成员指针运算符、`::`作用域解析运算符、`?`条件运算符、typeid：一个RTTI运算符、const_cast、dynamic_cast，reinterpret_cast、statuc_cast:强制类型转换运算符；
   * 大多数运算符都可以通过成员或非成员函数进行重载，但以下符号只能通过成员哈桑农户进行重载：`=`赋值运算符；`()`函数调用运算符；`[]`小标运算符；`->`通过指针访问类成员的运算符。
### 友元
1. C++提供了另一种访问类私有成员的访问权限：友元。友元有三种：友元函数、友元类、友元成员函数。通过让函数称为类的友元，可以赋予该函数与类成员函数相同的访问权限。
2. 常规非成员函数不能访问类的私有成员，但是友元函数可以访问类的私有成员。
3. 创建友元函数的第一步是将其原型放在类声明中，并在原型声明前加上关键字friend：（当定义同时也是原型时要使用friend前缀）
   ```cpp
   friend Time operator*(double m, const Time & t); // goes in class declaration
   ```
   该原型意味着两点：
   * 虽然operator*()函数是在类声明中声明的，但它不是成员函数，因此不能使用成员运算符来调用；
   * 虽然不是成员函数，但与成员函数的访问权限相同。
4. 编写函数定义，因为不是成员函数，所以不使用Time::限定符，另外不要在定义中使用关键字friend。**总之，类的友元函数是非成员函数，其访问权限与成员函数相同。** 如果要为类重载运算符，并将非类的项作为其第一个操作数，则可以使用友元函数来反转操作数的顺序。
5. 通过使用友元函数重载<<运算符。
6. 描述对象所处的状态的成员被称为状态成员（state member）
### 类的自动转换和强制类型转换
1. 强制类型转换 `int * p = (int *) 10;`将10强制转换为int指针类型（即int *类型），将指针设置为地址10.
2. 只有接收一个参数的构造函数才能作为转换函数，如果给第二个参数提供默认值便可用于转换。
3. 关键字explicit限定了构造函数只能用于显式转换。否则也可以用于隐式转换。
4. 构造函数只用于从某种类型到类类型的转换，要进行相反的转换，必须使用特殊的C++运算符函数————转换函数。转换函数是用户定义的强制类型转换。创建转换函数：`operator typeName();`，注意：
   * 转换函数必须是类方法；意味着需要通过类对象调用，从而告知函数要转换的值，因此不需要参数。
   * 转换函数必能指定返回类型；
   * 转换函数不能有参数。
5. 在C++11中，可将转换运算符声明为显式的：`explicit opetator int() const;`，另一种方法是用一个功能相同的非转换函数替换该转换函数即可。
6. 总之，C++为类提供了下面的类型转换：
   * 只有一个参数的类构造函数用于将类型与该参数相同的值值转换为类类型。在构造函数声明中使用explicit可防止隐式转换，而只允许显式转换
   * 被称为转换函数的特殊类成员运算符函数，用于将类对象转换为其他类型。转换函数是类成员，没有返回类型、没有参数、名为operator typeName()，其中type Name是对象将被转换成的类型，将类对象赋给typeName变量或将其强制转换为typeName类型时，该转换函数将自动被调用。
7. 将加法定义为友元可以让程序更容易适应自动类型转换，操作数都成为函数参数。
***
## 第十一章复习重点
1. 友元函数和成员函数之间的区别？
   成员函数是类定义的一部分，通过特定的对象来调用。成员函数可以隐式访问调用对象的成员，而无需使用成员运算符。友元函数不是类的组成部分，因此被称为直接函数调用。友元函数不能隐式访问类成员，而必须将成员运算符用于作为参数传递的对象。
2. 非成员函数必须是友元才能访问类成员吗？
   要访问私有成员，它必须是友元，但要访问公有成员可以不是友元。
3. 哪些运算符不能重载？
   `sizeof`、`.`、`.*`、`::`、`?:`
4. 在重载运算符=、()、[]和->时，有什么限制？
   这些运算符必须使用成员函数来定义。
***
## 第十二章 类和动态内存分配
1. 静态类成员特点：无论创建了多少对象，程序都只创建一个静态类成员副本，即类的所有对象共享同一个静态成员。**不能在类声明中初始化静态成员变量，因为声明描述了如何分配内存，但并不分配内存。**初始化语句指出类型，并使用了作用域运算符，但不使用关键字static。初始化是在方法文件中而不是在类声明文件中进行的，因为类声明位于头文件中，程序可能将头文件包括在其他几个文件中，如果在头文件中进行初始化，将出现多个初始化语句副本，引发错误。
2. *静态数据成员在类声明中声明，在包含类方法的文件中初始化。初始化时使用作用域运算符来指出静态成员所属的类，但如果静态成员是整形或枚举型const，则可以在类声明中初始化。
3. 在构造函数中使用new来分配内存时，必须在相应的析构函数中使用delete来释放内存，如果使用`new[]`来分配内存，则应使用`delete[]`来释放内存。
4. 当使用一个对象初始化另一个对象时，编译器将自动生成构造函数，称为复制构造函数。
5. C++自动生成了这些成员函数：
   * 默认构造函数，如果没有定义构造函数；
   * 默认析构函数，如果没有定义；
   * 赋值构造函数，如果没有定义；
   * 赋值运算符，如果没有定义；
   * 地址运算符，如果没有定义。
6. **默认构造函数** 如果没有提供任何构造函数，C++将创建默认构造函数。不接受任何参数，也不执行任何操作。带参数的构造函数也可以是默认构造函数，只要所有参数都有默认值。
7. **复制构造函数** 用于将一个对象复制到新创建的对象中。也就是说，用于初始化过程中（包括按值传递参数），而不是常规的赋值过程。类的复制构造函数原型通常如下：`Class_name(const Class_name &);`  *何时调用复制构造函数：*新建一个对象并对其初始化为同类现有对象时，复制构造函数都将被调用，最常见的情况是将新对象显式地初始化为现有的对象。按值传递和返回对象时，都将调用复制构造函数。*默认复制构造函数的功能：*逐个复制非静态成员（成员复制也成为浅复制），复制的是成员的值，如果成员本身就是类对象，则将使用这个类的复制构造函数来复制成员对象。静态函数不受影响，因为它们属于整个类而不是各个对象。
8. 程序内出现生成受损的字符串，通常是内存管理不善的表现。
9. 如果类中包含了使用new初始化的指针成员，应当定义一个复制构造函数，以复制指向的数据而不是指针这称为深度复制。复制的另一种形式（成员复制或浅复制）只是复制指针值，浅复制仅浅浅地复制指针信息，而不会深入挖掘以复制指针引用地结构。
10. C++允许类对象赋值，这是通过自动为类对象重载赋值运算符实现的。
    ```cpp
    Class_name & Class_name::operator=(const Class_name &);
    ```
    将已有的对象赋值给另一个对象时，将使用重载的赋值运算符。 
11. `delete[]`与使用`new[]`初始化的指针和空指针都兼容，对于以其他方式初始化的指针，使用`delete[]`结果将是不确定的。
12. C++11引入新关键字nullptr，表示空指针。
13. 可以将成员函数声明为静态的（函数声明必须包含关键字static，但如果函数定义是独立的，则其中不能包含关键字static），有两个重要后果：首先，不能通过对象调用静态成员函数，实际上甚至不能使用this指针，如果静态成员函数是在公有部分声明的，则可以使用类名和作用域解析运算符来调用；其次，由于静态成员函数不予特定对象关联，因此只能使用静态数据成员。
14. 使用new初始化对象的指针成员式必须特别小心，具体地说：
    * 如果在构造函数中使用new初始化指针成员，则应在析构函数中使用delete；
    * new和delete必须相互兼容，`new`对应`delete`，`new[]`对应于`delete[]`
    * 如果有多个构造函数，则必须以相同的方式使用new，要么都带中括号要么都不带，因为只有一个析构函数，所有构造函数都必须与其兼容。但是，可以在一个构造函数中使用new初始化指针，而在另一个构造函数中将指针初始化为空，因为delete（无论带中括号还是不带中括号）都可以用于空指针。
    * 应定义一个复制构造函数通过深度复制将一个对象初始化为另一个对象。**复制构造函数应该分配足够的空间来存储复制的数据，并复制数据，而不仅仅是数据的地址，另外，还应该更新所有受影响的静态类成员。**
    * 应当定义一个赋值运算符，通过深度复制将一个对象复制给另一个对象。
15. * 返回指向const对象的引用旨在提高效率。返回对象将调用复制构造函数，而返回引用不会；引用指向的对象应该在调用函数执行时存在。
    * 返回指向非const对象的引用，两种常见的返回非const对象情形是，重载赋值运算符以及重载与cout一起使用的<<运算符，前者这样做旨在提高效率，后者必须这样做。
    * 返回对象 如果被返回的对象是被调用函数中的局部变量，则不应该按引用方式返回它，在被调用函数执行完毕时，局部对象将调用析构函数，当控制权回到调用函数时，引用指向的对象将不再存在。因此应返回对象而不是引用。
    * 返回const对象 
    * **总之：**如果方法或函数要返回局部对象则应返回对象，在这种情况下将使用复制构造函数来生成返回的对象。如果方法或函数要返回没有公有复制构造函数的类对象，必须返回一个指向这种对象的引用。有些方法和函数可以返回对象也可以返回指向对象的引用，这种情况下首选引用，因为效率更高。
16. 使用指向对象的指针 对象是单个的因此程序使用不带括号的delete
    在下述情况下析构函数将被调用：
    * 如果对象是动态变量，则当执行完定义该对象的程序块时，将调用该对象的析构函数。
    * 如果对象是静态变量（外部、静态、镜头外部或来自名称空间），则在程序结束时将调用对象的析构i函数。
    * 如果对象是用new创建的，则仅当显式使用delete删除对象时，析构函数才会被调用。
17. 使用对象指针时，需要注意几点：
    * 使用常规表示法来声明指向对象的指针`String * glamour;`
    * 可以将指针初始化为指向已有的对象`String * first = &sayings[0];`；
    * 可以使用new来初始化指针，这将创建一个新的对象`String * favorite = new String(sayings[choice]);`；
    * 对类使用new将调用相应的类构造函数来初始化新创建的对象`String * gleep = new String;`；
    * 可以使用`->`运算符通过指针访问类方法
    * 可以对对象指针应用接触引用运算符（*）来获得对象。
18. *定位new运算符* 教训：1. 程序员必须负责管用定位new运算符用从中使用的缓冲区内存单元，要使用不同的内存单元，程序员需要提供两个位于缓冲区的不同地址，并确保这两个内存单元不重叠；2. 如果使用定位new运算符来为对象分配内存，必须确保其析构函数被调用。delete可与常规new运算符配合使用，但不能与定位new运算符配合使用。delete[]buffer释放常规new运算符分配的整个内存块，但没有为定位new运算符在该内存块中创建的对象调用析构函数。  对于使用定位new运算符创建的对象，应以创建顺序相反的顺序尽心删除，原因在于晚创建的对象可能依赖于早创建的对象，另外仅当所有对象都被销毁后才能释放用于存储这些对象的缓冲区。
19. 复习各种技术
    * 重载`<<`运算符
        定义友元运算符函数
        ```cpp
        ostream & operator<<(ostream & os, const c_name & obj)
        {
            os<<...; //display object cintents
            return os;
        }
        ```
    * 转换函数
        要将单个值转换为类类型，需要创建如下构造函数：`c_name(type_name value);`
        要将类转换为其他类型，需要创建如下类成员函数：`operator type_name();`虽然该函数没有声明返回类型，但应返回所需类型的值。
        使用转换函数应小心，可以在声明构造函数时使用关键字explicit以防止被用于隐式转换。
    * 构造函数使用new的类
        1. 对于指向的内存是由new分配的所有类成员，都应在类的析构函数中对其使用delete
        2. 如果析构函数通过对指针类成员使用delete来释放内存，则每个构造函数都应当使用new来初始化指针，或将它设置为空指针。
        3. 构造函数中要么使用`new[]`，要么使用`new`，而不能混用。如果构造函数使用的是`new[]`，则析构函数应使用`delete[]`，new对应delete。
        4. 应定义一个分配内存（而不是将指针指向已有内存）的复制构造函数，这样程序将能够将类对象初始化为另一个类对象，复制构造函数的原型：`className（const className &)`
        5. 应定义一个重载赋值运算符的类成员函数，函数定义如下（其中c_pointer是c_name的类成员，类型为指向type_name的指针）
            ```cpp
            c_name & c_name::operator=(const c_name & cn)
            {
                if(this == &cn)
                    return *this;
                delete [] c_pointer;
                // set size number of type_name units to be copied
                c_pointer = new type_name[size];
                // then copy data pointed to by cn.c_pointer to
                // location pointed to by c_pointer
                ...
                return * this;
            }
20. **队列模拟** 栈是一种后进后出（LIFO）的结构，队列是先进先出（FIFO）的。**链表**由节点序列构成，每一个节点中都包含要保存的链表中的信息以及一个指向下一个节点的指针，通常链表最后一个节点中的指针被设置为NULL或0.
21. 在类中嵌套结构或类声明，其作用域为整个类，可以使用它来声明类成员，也可以将其作为类方法中的类型名称，但只能在类中使用。这种声明不会创建数据对象，而只是指定了可以在类中使用的类型。如果声明是在类的私有部分进行的，则只能在这个类使用被声明的对象；如果声明是在公有部分进行的，则可以从类的外部通过作用域解析运算符使用被声明的类型。
22. 成员初始化列表 由逗号分隔的初始化列表组成（前面带冒号），位于参数列表的右括号之后、函数体左括号之前，如果成员的名称为mdata，初始化为val，则初始化器为mdata(val)。通常处置可以是常量或构造函数的参数列表中的参数。*只有构造函数可以使用这种初始化列表语法*，对于const类成员必须使用这种用法，对于被声明为引用的类成员也必须使用这种语法。*对于本身就是类对象的成员来说，使用成员初始化列表的效率更高*。
    * 这种格式只能用于构造函数
    * 必须用这种格式来初始化非静态const成员（C++11之前是这样的）
    * 必须用这种格式来初始化引用数据成员。
    数据成员被初始化的顺序与出现在类声明中的顺序相同，与初始化器中的排列顺序无关。
23. 